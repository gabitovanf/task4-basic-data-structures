Algorithms course
# Topic 4 homework

## Динамические массивы, неполный массив, очередь с приоритетом.

### Цель:

Создание разных алгоритмов для реализации Динамического массива и сравнение их производительности. Создание приоритетной очереди или неполного массива.

### 1 задание. Динамические массивы

Написать метод добавления и удаления элементов:

- void add(T item, int index);
- T remove(int index); // возвращает удаляемый элемент

по индексу во все варианты динамических массивов:

SingleArray + , VectorArray + , FactorArray + , MatrixArray + *.

**+3 байта**

### 2 задание. Таблица сравнения производительности

Сравнить время выполнения разных операций
для разных массивов с разным порядком значений.

- сделать обёртку над ArrayList() и тоже сравнить. + 

Составить таблицу и приложить её скриншот.

Сделать выводы и сформулировать их в нескольких предложениях.

Ссылка на сравнительную таблицу: https://docs.google.com/spreadsheets/d/13Qw1LyXiJOeXcySPQREA2pSHtd54-HdR9Whwgvb86ds/edit?usp=sharing 

**+3 байта**

### 3 задание. Приоритетная очередь (на выбор)

Написать реализацию PriorityQueue - очередь с приоритетом.

Варианты реализации - список списков, массив списков

Методы к реализации:

- enqueue(int priority, T item) - поместить элемент в очередь
- T dequeue() - выбрать элемент из очереди

**+4 байта**

### 4 задание. Неполный массив (на выбор)

Написать Реализацию класса SpaceArray массив массивов с неполным заполнением.

Делать на основе одного из уже созданных массивов и/или списков.

**+4 байта дополнительно.**

Для реализации можно использовать только стандартные массивы [],
созданные классы массивов и/или списков. Стандартные коллекции не используем!

**ВАЖНО!** При размещении ответа укажите, на каком языке вы выполнили ДЗ. Это поможет нам ускорить его проверку.


### Критерии оценки:

1 задание. Динамические массивы. +3 байта

2 задание. Таблица сравнение производительности. +3 байта

3 задание (на выбор). Приоритетная очередь. +4 байта

4 задание (на выбор). Класс SpaceArray +4 байта


Вс. 5 марта - 5.5-6.5 часов
+ 1.5 часа на сборку xlsx
+ 1 ч +/- на прогон тестов
+ 1 ч +/- на отладку MatrixArray и местодов copy и итераторов
Очередь в1 + окружение: 4-5 часов
Очередь в2: 1 час

Байтов: 3 + 3 + 4 = 10

Выводы по таблице:

Добавление в конец (put(item)) работало эффективнее в случае FactorArray. Порядок значений времени был такой же как в обортке list()
Добавление по индексу (add(item, index)) близко к началу массивов работало в целом медленне чем добавление в конец. 
Однако в случае VectorArray время различалося почти на 1 порядок и растет быстрее порядка кол-ва операций, в случае FactorArray преимущество, которое наблюдалось при операции добавления в конец, терялось, и время выполнения добавления по порядковому номеру было того же порядка, что и для SingleArray и VectorArray.
Запроc по номеру (get(index)) работал почти одинаково эффективно во всех вариантах кроме MatrixArray. В случае MatrixArray тратилось почти на порядок больше времени. 
Удаление по номеру (remove(index)) оказалось наиболее затратной операцией для всех вариантов. Скорость работы зависела от исходной длины массива. При этом удаление по номеру из нативного list() так же зависело от объема исходного массива, однако скорось была значительно лучше, чем в рассмотренных реализациях почти на 3 порядка.
Определение размера (size()) по порядку величигы затраченного времени практически не отличалось для разных вариантов реализации.
Судя по таблица по всем операциям кроме добавления в конец наименее эффективная реализация - MatrixArray. Добавление в конец самое медленное у SingleArray.
Более высокую эффективность показал FactorArray при добавлении в конец при длине массива >= 100. При длине меньше 100 эффективнее VectorArray.

